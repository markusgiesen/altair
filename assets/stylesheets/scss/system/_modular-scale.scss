// --------------------------------------------------------------------------
// Modular scale
// --------------------------------------------------------------------------
// URL: https://github.com/Team-Sass/modular-scale/tree/2.x/stylesheets
// --------------------------------------------------------------------------
// Last udpated: 2014-01-12
// --------------------------------------------------------------------------

// Defaults
// --------------------------------------------------------------------------

$ms-base: 1em !default;
$ms-ratio: 1.618033989 !default;

// Modular scale functions
// --------------------------------------------------------------------------

// Feature testing (_tests.scss)
// --------------------------------------------------------------------------

// Test if the pow() function exists
@function ms-pow-exists() {
	@if pow(4, 2) == 16 {
		@return true;
	}
	@return false;
}

$MS-pow-exists: ms-pow-exists();

// Test if MS was installed via the gem
@function ms-gem-exists() {
	@if ms-gem-installed() == true {
		@return true;
	}
	@return false;
}

$MS-gem-exists: ms-gem-exists();

// Exponent (_pow.scss)
// --------------------------------------------------------------------------

// If a native exponent function doesnt exist
// this one is needed.
@function ms-pow($Base, $Exponent) {

	// Find and remove unit.
	// Avoids messyness with unit calculations
	$Unit: $Base * 0 + 1;
	$Base: $Base/$Unit;

	// This function doesnt support non-interger exponents.
	// Warn the user about why this is breaking.
	@if round($Exponent) != $Exponent {
		@warn "Unfortunately, you need Compass to use non-integer exponents";
	}

	// Set up the loop, priming the return with the base.
	$Return: $Base;

	// If the number is positive, multiply it.
	@if $Exponent > 0 {
		// Basic feedback loop as exponents
		// are recursivley multiplied numbers.
		@for $i from 1 to $Exponent {
			$Return: $Return * $Base;
		}
	}

	// If the number is 0 or negitive
	// divide instead of multiply.
	@else {
		// Libsass doesnâ€™t allow negitive values in loops
		@for $i from (-1 + 1) to (abs($Exponent) + 1) {
			$Return: $Return / $Base;
		}
	}

	// Return is now compounded redy to be returned.
	// Add the unit back onto the number.
	@return $Return * $Unit;
}

// Calc (_calc.scss)
// --------------------------------------------------------------------------

@function ms-calc($Value, $Base: $ms-base, $Ratio: $ms-ratio) {

	// If pow exists use it.
	// It supports non-interger values!
	@if $MS-pow-exists {

		// The formula for figuring out modular scales is:
		// (r^v)*b
		@return pow($Ratio, $Value) * $Base;
	}

	// If not, use ms-pow().
	// Not as fast or capable of non-integer exponents.
	@else {
		@return ms-pow($Ratio, $Value) * $Base;
	}
}

// Generate list (_generate-list.scss)
// --------------------------------------------------------------------------

@function ms-reverse-list($list) {
	@if length($list) > 1 {
		@if nth($list, 1) > nth($list, length($list)) {
			$MS-reversed-list: ();
			@each $Value in $list {
				$MS-reversed-list: join($Value, $MS-reversed-list);
			}
			@return $MS-reversed-list;
		}
	}
	@return $list;
}

@function ms-generate-list($Value: 0, $Bases: $ms-base, $Ratios: $ms-ratio) {

	// Create blank lists
	$MS-list: ();
	$MS-base-list: ();

	// Loop through each ratio AND each base
	// to generate all possibilities.
	@each $Ratio in $Ratios {
		@each $Base in $Bases {

			// Set base variables
			$MS-base-list: ();
			$Base-counter: 0;

			// Seed list with an initial value
			@if $Base == $Base {
				$MS-base-list: $Base;
			}

			// Find values on a positive scale
			@if $Value >= 0 {

				// Find lower values on the scale
				$Base-counter: -1;
				@while ms-calc($Base-counter, $Base, $Ratio) >= nth($Bases, 1) {
					$MS-base-list: join($MS-base-list, ms-calc($Base-counter, $Base, $Ratio));
					$Base-counter: $Base-counter - 1;
				}

				// Ensure the list is smallest to largest
				$MS-base-list: ms-reverse-list($MS-base-list);

				// Find higher possible values on the scale
				$Base-counter: 1;
				@while ms-calc($Base-counter, $Base, $Ratio) <= ms-calc($Value, nth($Bases, 1), $Ratio) {
					$MS-base-list: join($MS-base-list, ms-calc($Base-counter, $Base, $Ratio));
					$Base-counter: $Base-counter + 1;
				}
			}

			// Find values on a negitive scale
			@if $Value < 0 {

				// Find lower values on the scale
				$Base-counter: 1;
				@while ms-calc($Base-counter, $Base, $Ratio) <= nth($Bases, 1) {
					$MS-base-list: join($MS-base-list, ms-calc($Base-counter, $Base, $Ratio));
					$Base-counter: $Base-counter + 1;
				}

				// Ensure the list is smallest to largest
				$MS-base-list: ms-reverse-list($MS-base-list);

				// Find higher possible values on the scale
				$Base-counter: -1;
				@while ms-calc($Base-counter, $Base, $Ratio) >= ms-calc($Value, nth($Bases, 1), $Ratio) {
					$MS-calc: ms-calc($Base-counter, $Base, $Ratio);
					// detect if the value excedes the main base value
					@if $MS-calc < nth($Bases, 1) {
						$MS-base-list: join($MS-base-list, $MS-calc);
					}
					$Base-counter: $Base-counter - 1;
				}

				// Trim outlier base.
				@if length($Bases) > 1 {
					@for $i from 2 through length($Bases) {
						@if nth($MS-base-list, 1) > nth($Bases, 1) {
							$MS-new-list: ();
							@for $i from 2 through length($MS-base-list) {
								$MS-new-list: join($MS-new-list, nth($MS-base-list, $i));
							}
							$MS-base-list: $MS-new-list;
						}
					}
				}
			}

			// reverse list if its largest to smallest
			$MS-base-list: ms-reverse-list($MS-base-list);

			// Add new possibilities to the master list
			$MS-list: append($MS-list, $MS-base-list, comma);

		}
	}

	// After all the possibilities are found, output a master list
	@return $MS-list;
}

// Sort list (_sort-list.scss)
// --------------------------------------------------------------------------

// List sorting via a modified merge-sort algorythmn
// http://en.wikipedia.org/wiki/Merge_sort

@function ms-merge($A, $B) {

	$Return: ();

	// Some empty lists get passed through
	// so just pass the other list throguh
	@if length($A) == 0 {
		@return $B;
	}

	// If lists fit next to each other, just merge them
	// This helps performance skipping the need to check each value
	@if nth($A, length($A)) < nth($B, 1) {
		@return join($A, $B);
	}
	@if nth($B, length($B)) < nth($A, 1) {
		@return join($B, $A);
	}

	// Counters start at 1
	$A-counter: 1;
	$B-counter: 1;

	// Start looping through all numbers in array
	@while $A-counter <= length($A) and $B-counter <= length($B) {

		// Check if the A value is smaller
		// Uses or equal to avoid duplicate numbers
		@if nth($A, $A-counter) <= nth($B, $B-counter) {
			$Return: join($Return, nth($A, $A-counter));
			$A-counter: $A-counter + 1;
		}

		// Check if the B value is smaller
		@elseif nth($A, $A-counter) > nth($B, $B-counter) {
			$Return: join($Return, nth($B, $B-counter));
			$B-counter: $B-counter + 1;
		}
	}


	// Run through remainder values in the list
	@while $A-counter <= length($A) {
		$Current: nth($A, $A-counter);
		@if $Current != nth($Return, length($Return)) {
			$Return: join($Return, $Current);
		}
		$A-counter: $A-counter + 1;
	}
	@while $B-counter <= length($B) {
		$Current: nth($B, $B-counter);
		@if $Current != nth($Return, length($Return)) {
			$Return: join($Return, $Current);
		}
		$B-counter: $B-counter + 1;
	}

	// Done! return is now sorted and complete
	@return $Return;
}

// Pull it all together
@function ms-sort-list($Lists) {

	$Return: ();

	@each $List in $Lists {
		@if $Return == () {
			$Return: $List;
		}
		@else {
			$Return: ms-merge($List, $Return);
		}
	}

	// final cleanup of repeated items
	$Last: null;
	$New-list: ();
	@each $Item in $Return {
		@if $Item != $Last {
			$New-list: join($New-list, $Item);
		}
		$Last: $Item;
	}
	$Return: $New-list;

	@return $Return;
}

// Function (_function.scss)
// --------------------------------------------------------------------------

// The main function that brings it all together
@function ms($Value: 0, $Bases: $ms-base, $Ratios: $ms-ratio) {

	// If no multi-base or multi-ratio stuff is going on
	// then just retrn the basic calculaiton
	@if length($Bases) == 1 and length($Ratios) == 1 {
		@return ms-calc($Value, $Bases, $Ratios);
	}

	// Do calculations directly in Ruby when avalible
	@if $MS-gem-exists {

		// Remove units from bases
		$Unit: nth($Bases, 1) * 0 + 1;
		$Unitless-Bases: ();
		@each $Base in $Bases {
			$Base: $Base/$Unit;
			$Unitless-Bases: join($Unitless-Bases, $Base);
		}

		// Calculate natively in Ruby
		@return ms-gem-func($Value, $Unitless-Bases, $Ratios) * $Unit;
	}

	// Generate a list of all possible values
	$Return: ms-generate-list($Value, $Bases, $Ratios);

	// Sort the generated lists
	$Return: ms-sort-list($Return);

	// Reverse list if its negitive.
	@if $Value < 0 {
		$MS-new-return: ();
		@each $i in $Return {
			$MS-new-return: join($i, $MS-new-return);
		}
		$Return: $MS-new-return;
	}

	// Normalize value for counting from 1
	// Because CSS counts things from 1
	// So Sass does as well
	// So I get to write fun stuff like this
	$Value: abs($Value) + 1;

	// Find the correct value in the list
	$Return: nth($Return, $Value);

	@return $Return;
}

// Same function, different name, for good measure.
@function modular-scale($Value: 0, $Bases: $ms-base, $Ratios: $ms-ratio) {
	@return ms($Value, $Bases, $Ratios);
}

// Function list (_function-list.scss)
// --------------------------------------------------------------------------

// Outputs a list of values instead of a single value
@function ms-list($Start: 0, $End: 0, $Bases: $ms-base, $Ratios: $ms-ratio) {

	// Seed results
	$Positive-return: ();
	$Negitive-return: ();
	$Return: ();

	@if $End >= 0 {
		// Generate a list of all possible values
		$Positive-return: ms-generate-list($End, $Bases, $Ratios);

		// Sort the generated lists
		$Positive-return: ms-sort-list($Positive-return);

		// Trim list
		$Trim-list: ();
		// If the starting value is a positive number
		// trim the positive return from that
		@if $Start >= 0 {
			@for $i from ($Start + 1) through $End + 1 {
				$Trim-list: join($Trim-list, nth($Positive-return, $i));
			}
		}
		// If not, then include everything up to the end.
		@else {
			@for $i from 1 through $End + 1 {
				$Trim-list: join($Trim-list, nth($Positive-return, $i));
			}
		}
		$Positive-return: $Trim-list;
	}

	// Generate a negitive list
	@if $Start < 0 {
		// Generate a list of all possible values
		$Negitive-return: ms-generate-list($Start, $Bases, $Ratios);

		// Sort the generated lists
		$Negitive-return: ms-sort-list($Negitive-return);

		// Reverse negitive list results.
		$MS-new-return: ();
		@each $i in $Negitive-return {
			$MS-new-return: join($i, $MS-new-return);
		}
		$Negitive-return: $MS-new-return;

		// Trim list
		$Trim-list: ();
		@if $End < 0 {
			@for $i from abs($End) through (abs($Start) + 2) {
				$Trim-list: join(nth($Negitive-return, $i), $Trim-list);
			}
		}
		@else {
			@for $i from 2 through (abs($Start) + 1) {
				$Trim-list: join(nth($Negitive-return, $i), $Trim-list);
			}
		}
		$Negitive-return: $Trim-list;
	}

	// Join both positive and negitive possibilities.
	$Return: join($Negitive-return, $Positive-return);

	@return $Return;
}
